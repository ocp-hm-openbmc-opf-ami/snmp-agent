 /*
 * Note: this file originally auto-generated by mib2c
 * using mib2c.table_data.conf
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include <net-snmp/agent/var_struct.h>
#include "netSnmpHostsTable.hpp"

#include <signal.h>

#include <phosphor-logging/elog-errors.hpp>
#include <phosphor-logging/elog.hpp>
#include <phosphor-logging/lg2.hpp>


#include <sdbusplus/message/types.hpp>
#include <xyz/openbmc_project/Common/error.hpp>
#include <xyz/openbmc_project/Sensor/Value/server.hpp>

struct sensorData{
  std::string sensorName;
  double sensorValue;
};


constexpr auto sensorPaths = std::to_array<std::string_view>({
    "/xyz/openbmc_project/sensors/airflow",
    //"/xyz/openbmc_project/sensors/humidity",
    //"/xyz/openbmc_project/sensors/altitude",
    //"/xyz/openbmc_project/sensors/energy",
    //"/xyz/openbmc_project/sensors/utilization",
    "/xyz/openbmc_project/sensors/fan_tach",
    "/xyz/openbmc_project/sensors/temperature",
    "/xyz/openbmc_project/sensors/fan_pwm",
    "/xyz/openbmc_project/sensors/voltage",
    "/xyz/openbmc_project/sensors/current",
     "/xyz/openbmc_project/sensors/power"
});


/** Initializes the netSnmpHostsTable module */
void
init_netSnmpHostsTable(void)
{
  /* here we initialize all the tables we're planning on supporting */
    initialize_table_netSnmpHostsTable();
}


/** Initialize the netSnmpHostsTable table by defining its contents and how it's structured */
void
initialize_table_netSnmpHostsTable(void)
{
    const oid netSnmpHostsTable_oid[] = {1,3,6,1,4,1,8072,2,2,2};
    const size_t netSnmpHostsTable_oid_len   = OID_LENGTH(netSnmpHostsTable_oid);
    netsnmp_handler_registration    *reg;
    netsnmp_tdata                   *table_data;
    netsnmp_table_registration_info *table_info;
    int                              ret;

    //DEBUGMSGTL(("netSnmpHostsTable:init", "initializing table netSnmpHostsTable\n"));


    std::ofstream fpchassis;
    fpchassis.open("/tmp/chassis.tmp",std::ios_base::app);
    fpchassis << "netSnmpHostsTable:init = initializing table netSnmpHostsTable " << std::endl;
    fpchassis.close();
    
    reg = netsnmp_create_handler_registration("netSnmpHostsTable",
					      netSnmpHostsTable_handler,
					      netSnmpHostsTable_oid,
					      netSnmpHostsTable_oid_len,
					      HANDLER_CAN_RWRITE);

    table_data = netsnmp_tdata_create_table( "netSnmpHostsTable", 0 );
    if (NULL == table_data)
      {
        snmp_log(LOG_ERR,"error creating tdata table for netSnmpHostsTable\n");
        return;
      }
    table_info = SNMP_MALLOC_TYPEDEF( netsnmp_table_registration_info );
    if (NULL == table_info)
      {
        snmp_log(LOG_ERR,"error creating table info for netSnmpHostsTable\n");
        return;
      }
    netsnmp_table_helper_add_indexes(table_info,
				     ASN_OCTET_STR,  /* index: netSnmpHostName */
				     //ASN_OCTET_FLOAT, /* index: ADDITIONAL */
				     0);

    table_info->min_column = COLUMN_NETSNMPHOSTADDRESSTYPE;
    table_info->max_column = COLUMN_NETSNMPHOSTROWSTATUS;

    
    
    ret = netsnmp_tdata_register(reg, table_data, table_info);
    if (ret)
      {
        snmp_log(LOG_ERR, "%s: netsnmp_tdata_register() returned %d\n",
                 __func__, ret);
        return;
      }

    /* Initialise the contents of the table here */
    setup_sensorTable(table_data);
}

    /* Typical data structure for a row entry */
struct netSnmpHostsTable_entry {
    /* Index values */
    char netSnmpSensorRowIndex[2];
    size_t netSnmpSensorRowIndex_len;

    /* Column values */
    double netSnmpSensorValue;
    double old_netSnmpSensorValue;
    char netSnmpSensorName[64];
    size_t netSnmpSensorName_len;
    char old_netSnmpSensorName[64];
    size_t old_netSnmpSensorName_len;
  //long netSnmpHostStorage;
  //long old_netSnmpHostStorage;
    long netSnmpSensorRowStatus;

    int   valid;
};

/* create a new row in the table */
netsnmp_tdata_row *
netSnmpHostsTable_createEntry(netsnmp_tdata *table_data
                 , uint8_t* netSnmpRowIndex
                 , size_t netSnmpRowIndex_len
		 , std::string amiSensorName
		 , double amiSensorValue
                ) {
    struct netSnmpHostsTable_entry *entry;
    netsnmp_tdata_row *row;


    std::ofstream fpchassis;
    size_t i;
    /*
    std::string basePath = "/xyz/openbmc_project/sensors/temperature/";
    std::string amiSubStr;

    amiSubStr = amiSensorName.substr(basePath.size());
    fpchassis.open("/tmp/chassis.tmp",std::ios_base::app);
    fpchassis << "Create Entry " << amiSensorName << std::endl;
    fpchassis << "SubString " << amiSubStr << std::endl;
    fpchassis.close();

    std::string interface = "xyz.openbmc_project.Sensor.Value";
    amiSensorValue = getSensorInfo(amiSensorName,interface);
    */
    
    entry = SNMP_MALLOC_TYPEDEF(struct netSnmpHostsTable_entry);
    if (!entry)
      {
	fpchassis.open("/tmp/chassis.tmp",std::ios_base::app);
	fpchassis << "No Entry" << std::endl;
	fpchassis.close();
        return NULL;
      }
    row = netsnmp_tdata_create_row();
    if (!row)
      {
	fpchassis.open("/tmp/chassis.tmp",std::ios_base::app);
	fpchassis << "Failed to create Row " << std::endl;
	fpchassis.close();
	SNMP_FREE(entry);
        return NULL;
      }
    //row->data = entry;

    DEBUGMSGT(("netSnmpHostsTable:entry:create", "row 0x%x\n", (uintptr_t)row));
    
    memcpy(entry->netSnmpSensorRowIndex, netSnmpRowIndex, netSnmpRowIndex_len);
    entry->netSnmpSensorRowIndex_len = netSnmpRowIndex_len;

    entry->netSnmpSensorValue = 44.0;
    entry->netSnmpSensorValue = amiSensorValue;
    entry->old_netSnmpSensorValue = 0.0;
    
    for(i=0;i<amiSensorName.size();i++)
      {
	//entry->netSnmpSensorName[i] = amiSubStr[i];
	entry->netSnmpSensorName[i] = amiSensorName[i];
	entry->old_netSnmpSensorName[i] = 0;
      }

    //entry->netSnmpSensorName_len = 5;
    //entry->netSnmpSensorName_len = amiSubStr.size();
    entry->netSnmpSensorName_len = amiSensorName.size();
    entry->old_netSnmpSensorName_len = 0;

    //entry->netSnmpHostStorage = 46;
    //entry->old_netSnmpHostStorage = 47;
    
    entry->valid = 1;

    
    row->data = entry;
    
    // Add row to index
    //netsnmp_tdata_row_add_index( row, ASN_OCTET_STR,
    //                           entry->netSnmpHostName, netSnmpHostName_len);

    netsnmp_tdata_row_add_index( row, ASN_OCTET_STR,
                                 &(entry->netSnmpSensorRowIndex), sizeof(entry->netSnmpSensorRowIndex));
    
    if (table_data)
      {
	    netsnmp_tdata_add_row( table_data, row );
      }
    return row;
}

/* remove a row from the table */
void
netSnmpHostsTable_removeEntry(netsnmp_tdata     *table_data, 
                 netsnmp_tdata_row *row) {
    struct netSnmpHostsTable_entry *entry;

    std::ofstream fpchassis;
    fpchassis.open("/tmp/chassis.tmp",std::ios_base::app);
    fpchassis << "remove Entry " << std::endl;
    fpchassis.close();
    
    
    if (!row)
        return;    /* Nothing to remove */

    DEBUGMSGT(("netSnmpHostsTable:entry:remove", "row 0x%x\n", (uintptr_t)row));

    entry = (struct netSnmpHostsTable_entry *)row->data;
    SNMP_FREE( entry );   /* XXX - release any other internal resources */

    if (table_data)
        netsnmp_tdata_remove_and_delete_row( table_data, row );
    else
        netsnmp_tdata_delete_row( row );    
}


/** handles requests for the netSnmpHostsTable table */
int
netSnmpHostsTable_handler(
    netsnmp_mib_handler               *handler,
    netsnmp_handler_registration      *reginfo,
    netsnmp_agent_request_info        *reqinfo,
    netsnmp_request_info              *requests) {

    netsnmp_request_info       *request;
    netsnmp_table_request_info *table_info;
    netsnmp_tdata              *table_data;
    netsnmp_tdata_row          *table_row;
    struct netSnmpHostsTable_entry          *table_entry;
    int                         ret;

    DEBUGMSGTL(("netSnmpHostsTable:handler", "Processing request (%d)\n", reqinfo->mode));


    std::ofstream fpchassis;
    fpchassis.open("/tmp/chassis.tmp",std::ios_base::app);
    fpchassis << "Table handler " << std::endl;
    fpchassis.close();

    if(0)
      {
	handler = handler;
	reginfo = reginfo;
      }
    
    switch (reqinfo->mode) {
        /*
         * Read-support (also covers GetNext requests)
         */
    case MODE_GET:
        for (request=requests; request; request=request->next)
	  {
	    if (request->processed)
	      continue;
	    
	    table_entry = (struct netSnmpHostsTable_entry *) netsnmp_tdata_extract_entry(request);
	    table_info = netsnmp_extract_table_info( request);
	    
	    switch (table_info->colnum)
	      {
	      case COLUMN_NETSNMPHOSTADDRESSTYPE:
                if ( !table_entry )
		  {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
		  }
                //snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
		//                          table_entry->netSnmpSensorValue);
		snmp_set_var_typed_value( request->requestvb, ASN_OPAQUE_DOUBLE,
                                          &table_entry->netSnmpSensorValue,
                                          sizeof(table_entry->netSnmpSensorValue));
                break;
	      case COLUMN_NETSNMPHOSTADDRESS:
                if ( !table_entry )
		  {
		    netsnmp_set_request_error(reqinfo, request,
					      SNMP_NOSUCHINSTANCE);
                    continue;
		  }
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                          table_entry->netSnmpSensorName,
                                          table_entry->netSnmpSensorName_len);
                break;
		/*
	      case COLUMN_NETSNMPHOSTSTORAGE:
                if ( !table_entry )
		  {
		    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
		  }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->netSnmpHostStorage);
                break;
		*/
	      case COLUMN_NETSNMPHOSTROWSTATUS:
                if ( !table_entry )
		  {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
		  }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->netSnmpSensorRowStatus);
                break;
	      default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHOBJECT);
                break;
	      }
	  }
        break;
	
        /*
         * Write-support
         */
    case MODE_SET_RESERVE1:
      for (request=requests; request; request=request->next)
	{
            if (request->processed)
	      continue;
            table_entry = (struct netSnmpHostsTable_entry *) netsnmp_tdata_extract_entry(request);
            table_info = netsnmp_extract_table_info( request);
	    
            switch (table_info->colnum)
	      {
	      case COLUMN_NETSNMPHOSTADDRESSTYPE:
                /* or possibly 'netsnmp_check_vb_int_range' */
                //ret = netsnmp_check_vb_int( request->requestvb );
		ret = netsnmp_check_vb_type_and_max_size(request->requestvb, ASN_OPAQUE_DOUBLE, sizeof(table_entry->netSnmpSensorValue));
                if ( ret != SNMP_ERR_NOERROR )
		  {
		    netsnmp_set_request_error( reqinfo, request, ret );
		    return SNMP_ERR_NOERROR;
		  }
                break;
	      case COLUMN_NETSNMPHOSTADDRESS:
	        /* or possibly 'netsnmp_check_vb_type_and_size' */
                ret = netsnmp_check_vb_type_and_max_size(request->requestvb, ASN_OCTET_STR, sizeof(table_entry->netSnmpSensorName));
                if ( ret != SNMP_ERR_NOERROR )
		  {
		    netsnmp_set_request_error( reqinfo, request, ret );
		    return SNMP_ERR_NOERROR;
		  }
                break;
		/*
	      case COLUMN_NETSNMPHOSTSTORAGE:
                // or possibly 'netsnmp_check_vb_int_range' 
                ret = netsnmp_check_vb_int( request->requestvb );
                if ( ret != SNMP_ERR_NOERROR )
		  {
		    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
		  }
                break;
		*/
	      case COLUMN_NETSNMPHOSTROWSTATUS:
                ret = netsnmp_check_vb_rowstatus(request->requestvb,
						 (table_entry ? RS_ACTIVE : RS_NONEXISTENT ));
                if ( ret != SNMP_ERR_NOERROR )
		  {
		    netsnmp_set_request_error( reqinfo, request, ret );
		    return SNMP_ERR_NOERROR;
		  }
                break;
            default:
	        netsnmp_set_request_error( reqinfo, request,
					 SNMP_ERR_NOTWRITABLE );
	        return SNMP_ERR_NOERROR;
	      }
        }
      break;
      
    case MODE_SET_RESERVE2:
        for (request=requests; request; request=request->next)
	  {
            if (request->processed)
	      continue;
	    
            table_row  = netsnmp_tdata_extract_row(  request);
            table_data = netsnmp_tdata_extract_table(request);
            table_info = netsnmp_extract_table_info( request);
	    
            switch (table_info->colnum)
	      {
	      case COLUMN_NETSNMPHOSTROWSTATUS:
                switch (*request->requestvb->val.integer)
		  {
		  case RS_CREATEANDGO:
		  case RS_CREATEANDWAIT:
		    table_row = netSnmpHostsTable_createEntry(table_data
							      ,reinterpret_cast<uint8_t*>(table_info->indexes->val.string)
							      ,table_info->indexes->val_len,static_cast<std::string>("test"),0.0);
                    if (table_row)
		      {
			netsnmp_insert_tdata_row( request, table_row );
		      }
		    else
		      {
			netsnmp_set_request_error( reqinfo, request,
                                                   SNMP_ERR_RESOURCEUNAVAILABLE );
                        return SNMP_ERR_NOERROR;
		      }
		  }
	      }
	  }
        break;

    case MODE_SET_FREE:
        for (request=requests; request; request=request->next)
	  {
            if (request->processed)
	      continue;
	    
            table_entry = (struct netSnmpHostsTable_entry *)
	      netsnmp_tdata_extract_entry(request);
            table_row   =     netsnmp_tdata_extract_row(  request);
            table_data  =     netsnmp_tdata_extract_table(request);
            table_info  =     netsnmp_extract_table_info( request);
	    
            switch (table_info->colnum) {
            case COLUMN_NETSNMPHOSTROWSTATUS:
	      switch (*request->requestvb->val.integer)
		{
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
		  if (table_entry && !table_entry->valid)
		    {
		      netSnmpHostsTable_removeEntry(table_data, table_row );
		    }
                }
            }
	  }
        break;
	
    case MODE_SET_ACTION:
      for (request=requests; request; request=request->next)
	{
	  if (request->processed)
	    continue;
	  
	  table_entry = (struct netSnmpHostsTable_entry *)
	    netsnmp_tdata_extract_entry(request);
	  table_info  =     netsnmp_extract_table_info( request);
	  
	  switch (table_info->colnum)
	    {
	    case COLUMN_NETSNMPHOSTADDRESSTYPE:
	      table_entry->old_netSnmpSensorValue = table_entry->netSnmpSensorValue;
	      //table_entry->netSnmpSensorValue     = *request->requestvb->val.integer;
	      table_entry->netSnmpSensorValue     = *request->requestvb->val.doubleVal;
	      break;
	    case COLUMN_NETSNMPHOSTADDRESS:
	      memcpy( table_entry->old_netSnmpSensorName,
		      table_entry->netSnmpSensorName,
		      sizeof(table_entry->netSnmpSensorName));
	      table_entry->old_netSnmpSensorName_len = table_entry->netSnmpSensorName_len;
	      memset( table_entry->netSnmpSensorName, 0,
		      sizeof(table_entry->netSnmpSensorName));
	      memcpy( table_entry->netSnmpSensorName,
		      request->requestvb->val.string,
		      request->requestvb->val_len);
	      table_entry->netSnmpSensorName_len =
		request->requestvb->val_len;
	      break;
	      /*
            case COLUMN_NETSNMPHOSTSTORAGE:
                table_entry->old_netSnmpHostStorage = table_entry->netSnmpHostStorage;
                table_entry->netSnmpHostStorage     = *request->requestvb->val.integer;
                break;
	      */
            }
        }
        /* Check the internal consistency of an active row */
        for (request=requests; request; request=request->next) {
            table_entry = (struct netSnmpHostsTable_entry *)
                              netsnmp_tdata_extract_entry(request);
            table_info  =     netsnmp_extract_table_info( request);
    
            switch (table_info->colnum) {
            case COLUMN_NETSNMPHOSTROWSTATUS:
                switch (*request->requestvb->val.integer) {
                case RS_ACTIVE:
                case RS_CREATEANDGO:
                    if (/* XXX */0) {
                        netsnmp_set_request_error( reqinfo, request,
                                                   SNMP_ERR_INCONSISTENTVALUE );
                        return SNMP_ERR_NOERROR;
                    }
                }
            }
        }
        break;

    case MODE_SET_UNDO:
        for (request=requests; request; request=request->next) {
            if (request->processed)
                continue;

            table_entry = (struct netSnmpHostsTable_entry *)
                              netsnmp_tdata_extract_entry(request);
            table_row   =     netsnmp_tdata_extract_row(  request);
            table_data  =     netsnmp_tdata_extract_table(request);
            table_info  =     netsnmp_extract_table_info( request);
    
            switch (table_info->colnum) {
            case COLUMN_NETSNMPHOSTADDRESSTYPE:
	      table_entry->netSnmpSensorValue = table_entry->old_netSnmpSensorValue;
	      table_entry->old_netSnmpSensorValue = 0;
                break;
            case COLUMN_NETSNMPHOSTADDRESS:
                memcpy( table_entry->netSnmpSensorName,
                        table_entry->old_netSnmpSensorName,
                        sizeof(table_entry->netSnmpSensorName));
                memset( table_entry->old_netSnmpSensorName, 0,
                        sizeof(table_entry->netSnmpSensorName));
                table_entry->netSnmpSensorName_len =
                        table_entry->old_netSnmpSensorName_len;
                break;
		/*
            case COLUMN_NETSNMPHOSTSTORAGE:
                table_entry->netSnmpHostStorage = table_entry->old_netSnmpHostStorage;
                table_entry->old_netSnmpHostStorage = 0;
                break;
		*/
            case COLUMN_NETSNMPHOSTROWSTATUS:
                switch (*request->requestvb->val.integer)
		  {
		  case RS_CREATEANDGO:
		  case RS_CREATEANDWAIT:
                    if (table_entry && !table_entry->valid)
		      {
			netSnmpHostsTable_removeEntry(table_data, table_row );
		      }
		  }
                break;
            }
        }
        break;
    case MODE_SET_COMMIT:
        for (request=requests; request; request=request->next)
	  {
            if (request->processed)
	      continue;
	    
            table_entry = (struct netSnmpHostsTable_entry *)
	      netsnmp_tdata_extract_entry(request);
            table_row   =     netsnmp_tdata_extract_row(request);
            table_data  =     netsnmp_tdata_extract_table(request);
            table_info  =     netsnmp_extract_table_info(request);
	    
            switch (table_info->colnum)
	      {
	      case COLUMN_NETSNMPHOSTROWSTATUS:
                switch (*request->requestvb->val.integer)
		  {
		  case RS_CREATEANDGO:
                    table_entry->valid = 1;
                    /* Fall-through */
		  case RS_ACTIVE:
                    table_entry->netSnmpSensorRowStatus = RS_ACTIVE;
                    break;
		    
		  case RS_CREATEANDWAIT:
                    table_entry->valid = 1;
                    /* Fall-through */
		  case RS_NOTINSERVICE:
                    table_entry->netSnmpSensorRowStatus = RS_NOTINSERVICE;
                    break;
		    
		  case RS_DESTROY:
                    netSnmpHostsTable_removeEntry(table_data, table_row );
		  }
	      }
	  }
        break;
    }
    return SNMP_ERR_NOERROR;
}

void
setup_sensorTable(netsnmp_tdata *table_data)
{

  //std::string amiString;
  uint8_t amiRowIndex[2];
  size_t amiRowIndex_len;

  //std::vector<sensorData> amiSensorData;
  struct sensorData amiTest;
  
  
  std::ofstream fpchassis;
  fpchassis.open("/tmp/chassis.tmp",std::ios_base::app);
  fpchassis << "setup sensor table " << std::endl;
  fpchassis.close();
  
  amiRowIndex[0] = 1;
  amiRowIndex[1] = 1;
  amiRowIndex_len = 2;
  
  amiTest.sensorValue = 0.0;
  amiTest.sensorName = "Temp";
  //amiSensorData.push_back(amiTest);

  //ObjUsr objects;
  //double amiDbl;
  //std::string tempPath = "/xyz/openbmc_project/sensors/temperature/";
  //std::string basePath = "/xyz/openbmc_project/sensors/temperature/Inlet_BRD_Temp";
  std::string iface = "xyz.openbmc_project.Sensor.Value";
  std::vector<std::string> subPath;
  
  fpchassis.open("/tmp/chassis.tmp",std::ios_base::app);
  fpchassis << "handle SNMP Integer "  << std::endl;
  fpchassis.close();

  for(amiRowIndex[0]=1;amiRowIndex[0]<=sensorPaths.size();amiRowIndex[0]++)
    {

      fpchassis.open("/tmp/chassis.tmp",std::ios_base::app);
      fpchassis << "+++++++++++++++++++++++++++++++++++++++++++++++++++" << std::endl;
      fpchassis << "GET service for row  " << amiRowIndex[0]  << std::endl;
      fpchassis << "GET service for SensorPath[" << (amiRowIndex[0]-1) << "] " << sensorPaths[amiRowIndex[0]-1]  << std::endl;
      fpchassis.close();
      
      //subPath = getServicePath(tempPath,iface);
      subPath = getServicePath(sensorPaths[amiRowIndex[0]-1],iface);

      if(subPath.empty())
	{
	  fpchassis.open("/tmp/chassis.tmp",std::ios_base::app);
	  fpchassis << "No sensors for sensor Path " << sensorPaths[amiRowIndex[0]-1] << std::endl;
	  fpchassis.close();
	  continue;
	}
      
      for(size_t i=0;i<subPath.size();i++)
	{
	  //double getSensorInfo(std::string basePath, std::string interface)
	  amiTest.sensorName = subPath[i].substr(sensorPaths[amiRowIndex[0]-1].size());
	  amiTest.sensorValue = getSensorInfo( subPath[i], iface);
	  fpchassis.open("/tmp/chassis.tmp",std::ios_base::app);
	  //fpchassis << "service Path[" << i << "] " << subPath[i] << " = " << amiDbl  << std::endl;
	  fpchassis << "service Path[" << i << "] " << subPath[i] << " = " << amiTest.sensorValue  << std::endl;
	  fpchassis.close();
	  netSnmpHostsTable_createEntry(table_data,amiRowIndex,amiRowIndex_len,amiTest.sensorName,amiTest.sensorValue);
	  amiRowIndex[1]=i+1;
	}
    }
      /*
      objects.clear();
      //objects = getMapperObject(basePath,iface);
      objects = getMapperObject(subPath[0],iface);
      
      //get the sensor Information
      try
	{
	  for (const auto& [path, interfaces] : objects)
	    {
	      fpchassis.open("/tmp/chassis.tmp",std::ios_base::app);
	      fpchassis << "find iface in path " << path.str << std::endl;
	      //fpchassis << "iface " << interfaces << std::endl;
	      fpchassis.close();
	      auto it = interfaces.find(iface);
	      if (it != interfaces.end())
		{
		  auto propIt = it->second.find("Value");
		  if (propIt != it->second.end() && std::get<double>(propIt->second))
		    {
		      amiTest.sensorName = path.str.substr(sensorPaths[amiRowIndex[0]-1].size());
		      amiTest.sensorValue = std::get<double>(propIt->second);
		      fpchassis.open("/tmp/chassis.tmp",std::ios_base::app);
		      //fpchassis << "path " << path.str << std::endl;
		      fpchassis << "amiSensorName " << amiTest.sensorName << std::endl;
		      fpchassis << "amiSensorValue " << amiTest.sensorValue << std::endl;
		      fpchassis << "propIt second  " << std::get<double>(propIt->second) << std::endl;
		      fpchassis.close();
		      amiSensorData.push_back(amiTest);
		    }// propIt second
		  else
		    {
		      fpchassis.open("/tmp/chassis.tmp",std::ios_base::app);
		      fpchassis << "failed to find Value" << std::endl;
		      fpchassis.close();
		    }
		}//interface
	      else
		{
		  fpchassis.open("/tmp/chassis.tmp",std::ios_base::app);
		  fpchassis << "failed to find interfaces" << std::endl;
		  fpchassis.close();
		}
	    }// for loop
	  
	}
      catch (const std::bad_variant_access& e)
	{
	  fpchassis.open("/tmp/chassis.tmp",std::ios_base::app);
	  fpchassis << "failure" << std::endl;
	  fpchassis.close();
	}
      
      for(auto element : amiSensorData)
	{
	  netSnmpHostsTable_createEntry(table_data,amiRowIndex,amiRowIndex_len,element.sensorName,element.sensorValue);
	  //netSnmpHostsTable_createEntry(table_data,amiRowIndex,amiRowIndex_len,amiTest.sensorName,amiTest.sensorValue);
	  //netSnmpHostsTable_createEntry(table_data,amiRowIndex,amiRowIndex_len,amiSensorData[0].sensorName,amiSensorData[0].sensorValue);
	  //netSnmpHostsTable_createEntry(table_data,amiString.data(),amiStringLen);
	  amiRowIndex[1]++;
	}
    } 
      */
  return;
}


std::vector<std::string> getServicePath(std::string_view path, std::string& intf)
{
    // Object Mapper related
    static constexpr const char* objMapperService =
      "xyz.openbmc_project.ObjectMapper";
    static constexpr const char* objMapperPath =
      "/xyz/openbmc_project/object_mapper";
    static constexpr const char* objMapperInterface =
      "xyz.openbmc_project.ObjectMapper";
    auto depth = 0;

    std::ofstream fpchassis;
    fpchassis.open("/tmp/chassis.tmp",std::ios_base::app);
    fpchassis << "get service Path " << std::endl;
    fpchassis.close();

    //sdbusplus::bus_t bus{ipmid_get_sd_bus_connection()};
    auto bus = sdbusplus::bus::new_default();

    fpchassis.open("/tmp/chassis.tmp",std::ios_base::app);
    fpchassis << "get service Create mapper call " << std::endl;
    fpchassis.close();

    auto mapperCall = bus.new_method_call(objMapperService, objMapperPath,
                                          objMapperInterface, "GetSubTreePaths");


    fpchassis.open("/tmp/chassis.tmp",std::ios_base::app);
    fpchassis << "get servicePath Append mapper call " << std::endl;
    fpchassis.close();

    //setup dbus call
    mapperCall.append(path);
    mapperCall.append(depth);
    mapperCall.append(std::vector<std::string>{intf});

    std::vector<std::string> mapperResponse;
    
    try
      {
	fpchassis.open("/tmp/chassis.tmp",std::ios_base::app);
	fpchassis << "get service Path bus call " << std::endl;
	fpchassis.close();
	auto mapperResponseMsg = bus.call(mapperCall);

	//errors
	if (mapperResponseMsg.is_method_error())
	  {
	    fpchassis.open("/tmp/chassis.tmp",std::ios_base::app);
	    fpchassis << "get service Path error in mapper call " << std::endl;
	    fpchassis.close();
	    lg2::error("Error in mapper call");
	    phosphor::logging::elog<sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure>();
	  }
	
	
	fpchassis.open("/tmp/chassis.tmp",std::ios_base::app);
	fpchassis << "get service Path read " << std::endl;
	fpchassis.close();
	
	//response
	//std::map<std::string, std::vector<std::string>> mapperResponse;
	//std::vector<std::string> mapperResponse;
	mapperResponseMsg.read(mapperResponse);
      }
    catch (const sdbusplus::exception::SdBusError& e)
      {
	fpchassis.open("/tmp/chassis.tmp",std::ios_base::app);
	fpchassis << "Failed" << std::endl;
	fpchassis.close();
	return std::vector<std::string>({});
      }
    /*
    //errors
    if (mapperResponseMsg.is_method_error())
    {
        fpchassis.open("/tmp/chassis.tmp",std::ios_base::app);
        fpchassis << "get service Path error in mapper call " << std::endl;
        fpchassis.close();
        lg2::error("Error in mapper call");
        phosphor::logging::elog<sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure>();
    }


    fpchassis.open("/tmp/chassis.tmp",std::ios_base::app);
    fpchassis << "get service Path read " << std::endl;
    fpchassis.close();

    //response
    //std::map<std::string, std::vector<std::string>> mapperResponse;
    std::vector<std::string> mapperResponse;
    mapperResponseMsg.read(mapperResponse);
    */

    if (mapperResponse.size() == 0)
    {
        fpchassis.open("/tmp/chassis.tmp",std::ios_base::app);
        fpchassis << "get service Path invalid response from mapper " << std::endl;
        fpchassis.close();
        lg2::error("Invalid response from mapper");
        phosphor::logging::elog<sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure>();
    }


    fpchassis.open("/tmp/chassis.tmp",std::ios_base::app);
    fpchassis << "get service path return " << std::endl;
    fpchassis.close();

    return mapperResponse;
}
